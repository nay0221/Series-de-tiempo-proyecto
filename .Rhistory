idx_end <- idx_may + k - 1
# serie de desempleo hasta ese mes
y_train_k <- window(y_arima2, end = tiempos[idx_end])
# regresores hasta ese mes (misma longitud)
X_train_k <- Xreg_arima2[1:idx_end, , drop = FALSE]
# ajustamos ARIMAX(1,0,2)
fit_k <- Arima(
y_train_k,
order = c(1, 0, 2),
xreg  = X_train_k,
include.mean = TRUE
)
# regresores del mes que queremos pronosticar (1 paso adelante)
X_fc_k <- Xreg_arima2[idx_end + 1, , drop = FALSE]
# pronóstico a 1 paso
fc_k <- forecast(fit_k, h = 1, xreg = X_fc_k)
y_hat_dyn[k] <- as.numeric(fc_k$mean)
}
# convertir los pronósticos a ts: empiezan en el mes siguiente a mayo 2018
start_fc_time <- tiempos[idx_may + 1]
start_year    <- floor(start_fc_time)
start_month   <- cycle(y_arima2)[idx_may + 1]
y_hat_dyn_ts <- ts(
y_hat_dyn,
start     = c(start_year, start_month),  # en tu caso debería ser (2018, 6)
frequency = frequency(y_arima2)
)
y_hat_dyn_ts
autoplot(window(y_arima2, start = c(2017, 1))) +
autolayer(y_hat_dyn_ts, series = "Pronóstico dinámico (1 paso)",
linetype = "dashed") +
geom_vline(xintercept = tiempos[idx_may],
linetype = "dotted", colour = "red") +
labs(
title = "Pronóstico dinámico 1-paso (ARIMAX(1,0,2))",
x = "Tiempo", y = "Tasa de desempleo"
) +
theme_minimal()
start_year  <- start(y_hat_dyn_ts)[1] # Valores observados en el mismo período que los pronósticos dinámicos
start_month <- start(y_hat_dyn_ts)[2]
end_time    <- time(y_hat_dyn_ts)[length(y_hat_dyn_ts)]
end_year    <- floor(end_time)
end_month   <- cycle(y_hat_dyn_ts)[length(y_hat_dyn_ts)]
y_test_dyn <- window(
y_arima2,
start = c(start_year, start_month),
end   = c(end_year, end_month)
)
acc_dyn <- accuracy(y_hat_dyn_ts, y_test_dyn)[1, c("RMSE", "MAE", "MAPE")] # Metricas de error del pronóstico dinamico de 1 paso
acc_dyn
library(forecast)
## --- 1) Definir train y test a partir de mayo 2018 ---
tiempos <- time(y_arima2)
# Índice de mayo-2018 en y_arima2
idx_may <- which(floor(tiempos) == 2018 & cycle(y_arima2) == 5)
n <- length(y_arima2)
# Máximo número de observaciones disponibles después de mayo-2018
H_max <- n - idx_may
# Horizonte deseado (como dijo el profe, ~9 meses) pero sin pasarnos del ts
H <- min(9, H_max)
# Serie de prueba (test): desde junio-2018 hasta el mes H después
y_test <- window(
y_arima2,
start = tiempos[idx_may + 1],
end   = tiempos[idx_may + H]
)
length(y_test)   # debería ser H
## --- 2) Pronóstico dinámico 1-paso con ARIMAX(1,0,2) sobre el tramo de test ---
y_hat_dyn <- numeric(H)
for (k in 1:H) {
# Fin del tramo de entrenamiento en el paso k
idx_end <- idx_may + k - 1
# Train: desempleo hasta ese mes
y_train_k <- window(y_arima2, end = tiempos[idx_end])
# Train: regresores hasta ese mes
X_train_k <- Xreg_arima2[1:idx_end, , drop = FALSE]
# Ajuste ARIMAX(1,0,2)
fit_k <- Arima(
y_train_k,
order = c(1, 0, 2),
xreg  = X_train_k,
include.mean = TRUE
)
# Regressors para el mes que queremos pronosticar (uno adelante)
X_fc_k <- Xreg_arima2[idx_end + 1, , drop = FALSE]
# Pronóstico 1 paso
fc_k <- forecast(fit_k, h = 1, xreg = X_fc_k)
y_hat_dyn[k] <- as.numeric(fc_k$mean)
}
# Pasar los pronósticos a ts alineado con y_test
start_fc_time <- tiempos[idx_may + 1]
start_year    <- floor(start_fc_time)
start_month   <- cycle(y_arima2)[idx_may + 1]
y_hat_dyn_ts <- ts(
y_hat_dyn,
start     = c(start_year, start_month),
frequency = frequency(y_arima2)
)
## --- 3) Errores en el tramo de test (como en los otros modelos) ---
rmse <- function(obs, pred) sqrt(mean((obs - pred)^2))
mae  <- function(obs, pred) mean(abs(obs - pred))
rmse_dyn <- rmse(y_test, y_hat_dyn_ts)
mae_dyn  <- mae(y_test, y_hat_dyn_ts)
rmse_dyn; mae_dyn
autoplot(window(y_arima2, start = c(2016, 1))) +
autolayer(y_test,       series = "Test (observado)", colour = "black") +
autolayer(y_hat_dyn_ts, series = "Pronóstico dinámico (1 paso)",
linetype = "dashed", colour = "blue") +
geom_vline(xintercept = tiempos[idx_may],
linetype = "dotted", colour = "red") +
labs(
title = "Pronóstico dinámico 1-paso ARIMAX(1,0,2)\n(Train hasta mayo-2018, Test = 9 meses)",
x = "Tiempo", y = "Tasa de desempleo"
) +
theme_minimal()
autoplot(window(y_arima2, start = c(2016, 1))) +
autolayer(y_test,       series = "Test (observado)", colour = "black") +
autolayer(y_hat_dyn_ts, series = "Pronóstico dinámico (1 paso)",
linetype = "dashed", colour = "blue") +
geom_vline(xintercept = tiempos[idx_may],
linetype = "dotted", colour = "red") +
labs(
title = "Pronóstico dinámico 1-paso ARIMAX(1,0,2)\n(Train hasta mayo-2018, Test = 9 meses)",
x = "Tiempo", y = "Tasa de desempleo"
) +
theme_minimal()
autoplot(window(y_arima2, start = c(2016, 1))) +
autolayer(y_test,       series = "Test (observado)") +
autolayer(y_hat_dyn_ts, series = "Pronóstico dinámico (1 paso)",
linetype = "dashed") +
geom_vline(xintercept = tiempos[idx_may],
linetype = "dotted", colour = "red") +
labs(
title = "Pronóstico dinámico 1-paso ARIMAX(1,0,2)\n(Train hasta mayo-2018, Test = 9 meses)",
x = "Tiempo", y = "Tasa de desempleo"
) +
theme_minimal()
## --- 1) Definir train y test a partir de mayo 2018 ---
tiempos <- time(y_arima2)
# Índice de mayo-2018 en y_arima2
idx_may <- which(floor(tiempos) == 2018 & cycle(y_arima2) == 5)
n <- length(y_arima2)
# Máximo número de observaciones disponibles después de mayo-2018
H_max <- n - idx_may
# Horizonte deseado (~9 meses) sin pasarse del ts
H <- min(9, H_max)
# Serie de prueba (test): desde junio-2018 hasta el mes H después
y_test <- window(
y_arima2,
start = tiempos[idx_may + 1],
end   = tiempos[idx_may + H]
)
length(y_test)   # debería ser H
## --- 2) Pronóstico dinámico 1-paso con ARIMAX(1,0,2) sobre el tramo de test ---
y_hat_dyn <- numeric(H)
for (k in 1:H) {
# Fin del tramo de entrenamiento en el paso k
idx_end <- idx_may + k - 1
# Train: desempleo hasta ese mes
y_train_k <- window(y_arima2, end = tiempos[idx_end])
# Train: regresores hasta ese mes
X_train_k <- Xreg_arima2[1:idx_end, , drop = FALSE]
# Ajuste ARIMAX(1,0,2)
fit_k <- Arima(
y_train_k,
order = c(1, 0, 2),
xreg  = X_train_k,
include.mean = TRUE
)
# Regressors para el mes que queremos pronosticar (uno adelante)
X_fc_k <- Xreg_arima2[idx_end + 1, , drop = FALSE]
# Pronóstico 1 paso
fc_k <- forecast(fit_k, h = 1, xreg = X_fc_k)
y_hat_dyn[k] <- as.numeric(fc_k$mean)
}
# Pasar los pronósticos a ts alineado con y_test
start_fc_time <- tiempos[idx_may + 1]
start_year    <- floor(start_fc_time)
start_month   <- cycle(y_arima2)[idx_may + 1]
y_hat_dyn_ts <- ts(
y_hat_dyn,
start     = c(start_year, start_month),
frequency = frequency(y_arima2)
)
## --- 3) Medidas de error en el tramo de test (como en los otros modelos) ---
# accuracy(): mismo formato que el ejemplo del profe
acc_dyn <- accuracy(y_hat_dyn_ts, y_test)
acc_dyn
# Si quieres extraer RMSE y MAE explícitamente:
rmse_dyn <- acc_dyn["Test set","RMSE"]
mae_dyn  <- acc_dyn["Test set","MAE"]
rmse_dyn; mae_dyn
# Tomamos una ventana un poco más larga para ver el corte
y_plot <- window(y_arima2, start = c(2011, 1))
autoplot(y_plot, series = "Observado") +
autolayer(y_hat_dyn_ts,
series   = "Pronóstico dinámico ARIMAX(1,0,2)",
linetype = "dashed") +
geom_vline(xintercept = tiempos[idx_may],
linetype = "dotted", colour = "red") +
labs(
title    = "Pronóstico dinámico 1-paso ARIMAX(1,0,2)",
subtitle = "Train hasta mayo-2018, test dinámico en los 9 meses siguientes",
x = "Tiempo",
y = "Tasa de desempleo"
) +
theme_minimal()
library(forecast)
## --- 1) Definir train y test a partir de mayo 2018 ---
tiempos <- time(y_arima2)
# Índice de mayo-2018 en y_arima2
idx_may <- which(floor(tiempos) == 2018 & cycle(y_arima2) == 5)
n <- length(y_arima2)
# Máximo número de observaciones disponibles después de mayo-2018
H_max <- n - idx_may
# Horizonte deseado (como dijo el profe, ~9 meses) pero sin pasarnos del ts
H <- min(9, H_max)
# Serie de prueba (test): desde junio-2018 hasta el mes H después
y_test <- window(
y_arima2,
start = tiempos[idx_may + 1],
end   = tiempos[idx_may + H]
)
length(y_test)   # debería ser H
## --- 2) Pronóstico dinámico 1-paso con ARIMAX(1,0,2) sobre el tramo de test ---
y_hat_dyn <- numeric(H)
for (k in 1:H) {
# Fin del tramo de entrenamiento en el paso k
idx_end <- idx_may + k - 1
# Train: desempleo hasta ese mes
y_train_k <- window(y_arima2, end = tiempos[idx_end])
# Train: regresores hasta ese mes
X_train_k <- Xreg_arima2[1:idx_end, , drop = FALSE]
# Ajuste ARIMAX(1,0,2)
fit_k <- Arima(
y_train_k,
order = c(1, 0, 2),
xreg  = X_train_k,
include.mean = TRUE
)
# Regressors para el mes que queremos pronosticar (uno adelante)
X_fc_k <- Xreg_arima2[idx_end + 1, , drop = FALSE]
# Pronóstico 1 paso
fc_k <- forecast(fit_k, h = 1, xreg = X_fc_k)
y_hat_dyn[k] <- as.numeric(fc_k$mean)
}
# Pasar los pronósticos a ts alineado con y_test
start_fc_time <- tiempos[idx_may + 1]
start_year    <- floor(start_fc_time)
start_month   <- cycle(y_arima2)[idx_may + 1]
y_hat_dyn_ts <- ts(
y_hat_dyn,
start     = c(start_year, start_month),
frequency = frequency(y_arima2)
)
## --- 3) Errores en el tramo de test (como en los otros modelos) ---
rmse <- function(obs, pred) sqrt(mean((obs - pred)^2))
mae  <- function(obs, pred) mean(abs(obs - pred))
rmse_dyn <- rmse(y_test, y_hat_dyn_ts)
mae_dyn  <- mae(y_test, y_hat_dyn_ts)
rmse_dyn; mae_dyn
## --- 1) Definir train y test a partir de mayo 2018 ---
tiempos <- time(y_arima2)
# Índice de mayo-2018 en y_arima2
idx_may <- which(floor(tiempos) == 2018 & cycle(y_arima2) == 5)
n <- length(y_arima2)
# Máximo número de observaciones disponibles después de mayo-2018
H_max <- n - idx_may
# Horizonte deseado (~9 meses) sin pasarse del ts
H <- min(9, H_max)
# Serie de prueba (test): desde junio-2018 hasta el mes H después
y_test <- window(
y_arima2,
start = tiempos[idx_may + 1],
end   = tiempos[idx_may + H]
)
length(y_test)   # debería ser H
## --- 2) Pronóstico dinámico 1-paso con ARIMAX(1,0,2) sobre el tramo de test ---
y_hat_dyn <- numeric(H)
for (k in 1:H) {
# Fin del tramo de entrenamiento en el paso k
idx_end <- idx_may + k - 1
# Train: desempleo hasta ese mes
y_train_k <- window(y_arima2, end = tiempos[idx_end])
# Train: regresores hasta ese mes
X_train_k <- Xreg_arima2[1:idx_end, , drop = FALSE]
# Ajuste ARIMAX(1,0,2)
fit_k <- Arima(
y_train_k,
order = c(1, 0, 2),
xreg  = X_train_k,
include.mean = TRUE
)
# Regressors para el mes que queremos pronosticar (uno adelante)
X_fc_k <- Xreg_arima2[idx_end + 1, , drop = FALSE]
# Pronóstico 1 paso
fc_k <- forecast(fit_k, h = 1, xreg = X_fc_k)
y_hat_dyn[k] <- as.numeric(fc_k$mean)
}
# Pasar los pronósticos a ts alineado con y_test
start_fc_time <- tiempos[idx_may + 1]
start_year    <- floor(start_fc_time)
start_month   <- cycle(y_arima2)[idx_may + 1]
y_hat_dyn_ts <- ts(
y_hat_dyn,
start     = c(start_year, start_month),
frequency = frequency(y_arima2)
)
## --- 3) Medidas de error en el tramo de test (como en los otros modelos) ---
# accuracy(): mismo formato que el ejemplo del profe
acc_dyn <- accuracy(y_hat_dyn_ts, y_test)
acc_dyn
# Si quieres extraer RMSE y MAE explícitamente:
rmse_dyn <- acc_dyn["Test set","RMSE"]
mae_dyn  <- acc_dyn["Test set","MAE"]
rmse_dyn; mae_dyn
# Tomamos una ventana un poco más larga para ver el corte
y_plot <- window(y_arima2, start = c(2011, 1))
autoplot(y_plot, series = "Observado") +
autolayer(y_hat_dyn_ts,
series   = "Pronóstico dinámico ARIMAX(1,0,2)",
linetype = "dashed") +
geom_vline(xintercept = tiempos[idx_may],
linetype = "dotted", colour = "red") +
labs(
title    = "Pronóstico dinámico 1-paso ARIMAX(1,0,2)",
subtitle = "Train hasta mayo-2018, test dinámico en los 9 meses siguientes",
x = "Tiempo",
y = "Tasa de desempleo"
) +
theme_minimal()
y_train <- window(y_arima2, end = tiempos[idx_may])
X_train <- Xreg_arima2[1:idx_may, , drop = FALSE]
# Ajuste ARIMAX(1,0,2) solo en el train
fit_train_dyn <- Arima(
y_train,
order = c(1, 0, 2),
xreg  = X_train,
include.mean = TRUE
)
summary(fit_train_dyn)
# Medidas de error en TRAIN (como en los ejemplos del profe)
acc_train_dyn <- accuracy(fit_train_dyn)
acc_train_dyn
Si quieres quedarte solo con RMSE, MAE y MAPE:
rmse_train_dyn <- acc_train_dyn["Training set","RMSE"]
mae_train_dyn  <- acc_train_dyn["Training set","MAE"]
mape_train_dyn <- acc_train_dyn["Training set","MAPE"]
c(RMSE = rmse_train_dyn,
MAE  = mae_train_dyn,
MAPE = mape_train_dyn)
rmse_test_dyn <- acc_dyn["Test set","RMSE"]
mae_test_dyn  <- acc_dyn["Test set","MAE"]
mape_test_dyn <- acc_dyn["Test set","MAPE"]
res_arimax_dyn <- data.frame(
muestra = c("Train", "Test dinámico (h = 1)"),
RMSE    = c(rmse_train_dyn, rmse_test_dyn),
MAE     = c(mae_train_dyn,  mae_test_dyn),
MAPE    = c(mape_train_dyn, mape_test_dyn)
)
res_arimax_dyn
y_plot <- window(y_arima2, start = c(2017, 1))
autoplot(y_plot, series = "Observado") +
autolayer(y_hat_dyn_ts,
series   = "Pronóstico dinámico (1 paso)",
linetype = "dashed") +
geom_vline(xintercept = tiempos[idx_may],
linetype = "dotted", colour = "red") +
labs(
title    = "Pronóstico dinámico 1-paso (ARIMAX(1,0,2))",
subtitle = "Línea roja: corte en mayo-2018 (fin del train)",
x = "Tiempo", y = "Tasa de desempleo"
) +
theme_minimal()
# % de mejora
rmse_uni_test    <- acc_uni_test["Test set", "RMSE"]
# En que medida mejora el pronostico las variables consideradas
#Particion train test
n       <- length(y_arima2)
n_train <- floor(0.8 * n)
tiempos <- time(y_arima2)
y_train <- window(y_arima2, end   = tiempos[n_train])
y_test  <- window(y_arima2, start = tiempos[n_train + 1])
X_train <- Xreg_arima2[1:n_train, ]
X_test  <- Xreg_arima2[(n_train + 1):n, ]
#Modelo base: ARIMA(1,0,2) sin covariables
fit_uni_tr    <- Arima(y_train, order = c(1,0,2), include.mean = TRUE)
fc_uni_test   <- forecast(fit_uni_tr, h = length(y_test))
acc_uni_test  <- accuracy(fc_uni_test, y_test)
acc_uni_test  # aqui el RMSE, MAE, MAPE del test set para el ARIMA solo
#Modelo completo: ARIMAX(1,0,2) con todas las X
fit_arimax_tr   <- Arima(y_train, order = c(1,0,2),
xreg = X_train, include.mean = TRUE)
fc_arimax_test  <- forecast(fit_arimax_tr, h = length(y_test), xreg = X_test)
acc_arimax_test <- accuracy(fc_arimax_test, y_test)
acc_arimax_test # aqui los errores del test set para el ARIMAX completo
#estos chunks se estan haciendo porque se ocupa como base para comparar, luego se hizo de mannera mas optimizada pero son importantes
# % de mejora
rmse_uni_test    <- acc_uni_test["Test set", "RMSE"]
rmse_arimax_test <- acc_arimax_test["Test set", "RMSE"]
mae_uni_test     <- acc_uni_test["Test set", "MAE"]
mae_arimax_test  <- acc_arimax_test["Test set", "MAE"]
mape_uni_test    <- acc_uni_test["Test set", "MAPE"]
mape_arimax_test <- acc_arimax_test["Test set", "MAPE"]
mejora_rmse_test <- 100 * (rmse_uni_test  - rmse_arimax_test) / rmse_uni_test
mejora_mae_test  <- 100 * (mae_uni_test   - mae_arimax_test)  / mae_uni_test
mejora_mape_test <- 100 * (mape_uni_test  - mape_arimax_test) / mape_uni_test
mejora_rmse_test
mejora_mae_test
mejora_mape_test
#Funcion general para evaluar ARIMAX en train/test, se va a estar usando entonces no borrar
eval_arimax_test <- function(y, X, order = c(1,0,2), train_frac = 0.8) { #80-20
n <- length(y)
n_train <- floor(train_frac * n)
tiempos <- time(y)
# dividir y
y_train <- window(y, end   = tiempos[n_train])
y_test  <- window(y, start = tiempos[n_train + 1])
# dividir X (mismas filas)
X_train <- X[1:n_train, , drop = FALSE]
X_test  <- X[(n_train + 1):n, , drop = FALSE]
# ajustar y pronosticar
fit <- Arima(y_train, order = order, xreg = X_train, include.mean = TRUE)
fc  <- forecast(fit, h = length(y_test), xreg = X_test)
acc <- accuracy(fc, y_test)
# devolvemos solo el test set y columnas clave, metricas
out <- acc["Test set", c("RMSE", "MAE", "MAPE")]
return(out)
}
# y_arima2: desempleo alineado
# Xreg_arima2: IMAE_5, TC_3, TBP_3, IPC_4, ISMR_8
vars <- colnames(Xreg_arima2)
vars
full_perf <- eval_arimax_test(y_arima2, Xreg_arima2)
full_perf
#Entre mas empeore, mas importante es esa variable para predecir.
results_drop <- list()
for (v in vars) {
X_sub <- Xreg_arima2[, setdiff(vars, v), drop = FALSE]  # todas menos v, mas rapidito
perf  <- eval_arimax_test(y_arima2, X_sub)
results_drop[[v]] <- perf
}
# Pasar a data.frame bonito
drop_df <- do.call(rbind, results_drop)
rownames(drop_df) <- paste0("Sin_", vars)
drop_df
#recordemos lo de arriba que era el completo con este comparamos lo que nos de el output:
#
#       RMSE      MAE    MAPE
# 0.5426308 0.4412843 4.7016466
# repetir full_perf a mismo numero de filas
full_mat <- matrix(rep(as.numeric(full_perf), each = nrow(drop_df)),
ncol = 3, byrow = FALSE)
colnames(full_mat) <- colnames(full_perf)
rownames(full_mat) <- rownames(drop_df)
# % de deterioro al quitar cada variable
empeora_pct <- 100 * (drop_df - full_mat) / full_mat
empeora_pct
#recordemos los errores que salen de test set del arima sin covariables o sea el modelo base para poder hacer la comparacion de como se ve ese modelo con una de las variables
acc_uni_test["Test set", c("RMSE","MAE","MAPE")]
#Antes ibamos viendo el modelo completo - una variable(efectos marginales), aca mas bien vamos viendo la base y con una variable a la vez
results_single <- list() #modelos ARIMAX(1,0,2) con solo una X a la vez
for (v in vars) {
X_single <- Xreg_arima2[, v, drop = FALSE]
perf  <- eval_arimax_test(y_arima2, X_single)
results_single[[v]] <- perf
}
single_df <- do.call(rbind, results_single)
rownames(single_df) <- paste0("Solo_", vars)
single_df
#ocupo esto para ver que tanto mejora vs ARIMA univariado necesitamos tambien el desempeño del ARIMA sin X en test
# modelo solo ARIMA en test
eval_arima_test <- function(y, order = c(1,0,2), train_frac = 0.8) {
n <- length(y)
n_train <- floor(train_frac * n)
tiempos <- time(y)
y_train <- window(y, end   = tiempos[n_train])
y_test  <- window(y, start = tiempos[n_train + 1])
fit <- Arima(y_train, order = order, include.mean = TRUE)
fc  <- forecast(fit, h = length(y_test))
acc <- accuracy(fc, y_test)
acc["Test set", c("RMSE", "MAE", "MAPE")]
}
base_test <- eval_arima_test(y_arima2) #esto se puede hacer mejor sin repetir de nuevo cosas que ya se hicieron
#base_test
base_mat <- matrix(rep(as.numeric(base_test), each = nrow(single_df)),
ncol = 3, byrow = FALSE)
colnames(base_mat) <- colnames(base_test)
rownames(base_mat) <- rownames(single_df)
mejora_single_pct <- 100 * (base_mat - single_df) / base_mat
colnames(mejora_single_pct) <- c("RMSE", "MAE", "MAPE")
mejora_single_pct
#Lo mismo pero con porcentajes
#Funcion general para evaluar ARIMAX en train/test, se va a estar usando entonces no borrar
eval_arimax_test <- function(y, X, order = c(1,0,2), train_frac = 0.8) { #80-20
n <- length(y)
n_train <- floor(train_frac * n)
tiempos <- time(y)
# dividir y
y_train <- window(y, end   = tiempos[n_train])
y_test  <- window(y, start = tiempos[n_train + 1])
# dividir X (mismas filas)
X_train <- X[1:n_train, , drop = FALSE]
X_test  <- X[(n_train + 1):n, , drop = FALSE]
# ajustar y pronosticar
fit <- Arima(y_train, order = order, xreg = X_train, include.mean = TRUE)
fc  <- forecast(fit, h = length(y_test), xreg = X_test)
acc <- accuracy(fc, y_test)
# devolvemos solo el test set y columnas clave, metricas
out <- acc["Test set", c("RMSE", "MAE", "MAPE")]
return(out)
}
