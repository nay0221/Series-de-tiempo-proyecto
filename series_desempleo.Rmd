---
title: "Series Desempleo"
author: "Sofía Bocker"
output: html_document
---

```{r}
# Librerías
#install.packages("forecast")
library(readxl)
library(dplyr)
library(ggplot2)
library(forecast)
library(tseries)
library(urca)
library(zoo)
library(lubridate)
library(scales)
```

```{r}
# Base de datos
df <- read_excel("base_desempleo_series.xlsx") 


```


```{r}


```

```{r}
df %>%
  ggplot(aes(Fecha, `Tasa de desempleo`)) +
  geom_line() +
  geom_point() +
  labs(
    title = "Tasa de desempleo mensual Costa Rica (2010-2025)",
    x = "Año", y = "Tasa"
  )

```

```{r}
# asegurar que la columna 'Fecha' sea date y la ordena
df$Fecha <- ymd(df$Fecha)        # en caso de que sea date, no pasa nada
df <- df[order(df$Fecha), ]

# convertir las columnas a objetos ts mensuales
start_ts <- c(year(df$Fecha[1]), month(df$Fecha[1]))  # inicio (año, mes)

desemp_ts <- ts(df$`Tasa de desempleo`, start = start_ts, frequency = 12)
imae_ts   <- ts(df$IMAE,                 start = start_ts, frequency = 12)
ipc_ts   <- ts(df$IPC,                 start = start_ts, frequency = 12)
tipo_cambio_ts   <- ts(df$`Tipo de cambio (promedio)`,                 start = start_ts, frequency = 12)
tbp_ts   <- ts(df$TBP,                 start = start_ts, frequency = 12)

# graficar en varios paneles 
op1 <- par(mfrow = c(2,1), mar = c(3,4,3,1))
plot(desemp_ts, ylab = "", xlab = "", main = "Tasa de desempleo")
plot(imae_ts,   ylab = "", xlab = "", main = "IMAE")
par(op1)

op2 <- par(mfrow = c(2,1), mar = c(3,4,3,1))
plot(desemp_ts, ylab = "", xlab = "", main = "Tasa de desempleo")
plot(ipc_ts,   ylab = "", xlab = "", main = "IPC")
par(op2)

op3 <- par(mfrow = c(2,1), mar = c(3,4,3,1))
plot(desemp_ts, ylab = "", xlab = "", main = "Tasa de desempleo")
plot(tipo_cambio_ts,   ylab = "", xlab = "", main = "Tipo de cambio")
par(op3)

op4 <- par(mfrow = c(2,1), mar = c(3,4,3,1))
plot(desemp_ts, ylab = "", xlab = "", main = "Tasa de desempleo")
plot(tbp_ts,   ylab = "", xlab = "", main = "TBP")
par(op4)

```

Desempleo vs IMAE: 2010-2019 relativamente estable, 2020 brinco brusco en desempleo probablemente por pandemia, reducción IMAE. 2021-2025 desempleo adopta tendencia decreciente e IMAE tendencia creciente. Parecen tener relación inversa, lo cual tiene sentido: cuando el nivel de actividad se recupera, el mercado laboral mejora. ¿Rezago?

Desempleo vs IPC: 2014-2016 IPC pasa de estar cerca de 0 a ser negativo. 2016-2019 comportamiento relativamente estable. 2020 pico desempleo. 2022 pico inflación con un decrecimiento bastante rápido y luego crecimiento. Desempleo mantiene decrecimiento. No parece haber una relación, el movimiento de la inflación puede ser puramente por motivos exógenos.

Desempleo vs Tipo de Cambio: 2014-2015 relativamente estable. 2015-2019 parece haber crecimiento en ambas. 2022 pico en tipo de cambio (depreciación) y después baja (apreciación). No parece haber relación.

Desempleo vs TBP: TBP parece tener tendencia baja con una alza en 2022 y luego decrecimiento gradual. Desempleo mantiene decrecimiento a pesar de la alza de la TBP en 2022. No parece haber relación. 

```{r}
# esto no está bien hecho
ccf(desemp_ts, imae_ts, ylab = "CCovF", type = "covariance")
ccf(desemp_ts, ipc_ts, ylab = "CCovF", type = "covariance")
ccf(desemp_ts, tipo_cambio_ts, ylab = "CCovF", type = "covariance")
ccf(desemp_ts, tbp_ts, ylab = "CCovF", type = "covariance")
```

```{r}
ccf(desemp_ts, imae_ts, type="correlation")

```

## Ouliers 



```{r}

df <- df %>%
mutate(Fecha = as_date(Fecha)) %>%
arrange(Fecha) %>%
rename(tasa = `Tasa de desempleo`)

start_ts <- c(year(first(df$Fecha)), month(first(df$Fecha)))
unemp_ts <- ts(df$tasa, start = start_ts, frequency = 12)

```



```{r}

o <- forecast::tsoutliers(unemp_ts) #Deteccion outliers con forecast

# serie ajustada 

df_out <- df
df_out$es_outlier <- FALSE
if (length(o$index) > 0) {
df_out$es_outlier[o$index] <- TRUE
}

df_out$ajustada <- df_out$tasa
if (length(o$index) > 0) {
df_out$ajustada[o$index] <- o$replacements
}

# outliers detectados

resumen_out <- df_out %>%
filter(es_outlier) %>%
transmute(
Fecha,
valor_original = tasa,
valor_ajustado = ajustada,
delta = valor_original - valor_ajustado
)
resumen_out

```
```{r}
ggplot(df_out, aes(Fecha, tasa)) +
geom_line() +
geom_point() +
geom_point(data = subset(df_out, es_outlier), color = "red", size = 2) +
labs(title = "outliers detectados",
x = "Año", y = "Tasa (%)")

```

```{r}

df_long <- df_out %>%
select(Fecha, Original = tasa, Ajustada = ajustada) %>%
tidyr::pivot_longer(-Fecha, names_to = "serie", values_to = "valor")

ggplot(df_long, aes(Fecha, valor, linetype = serie)) +
geom_line() +
labs(title = "Original vs. Ajustada",
x = "Año", y = "Tasa (%)", linetype = "") +
theme(legend.position = "bottom")

```

La serie original presenta un pico alto en 2020–2021. Los meses identificados como outliers fueron reemplazados por valores consistentes con la tendencia local, ahora tenemos una serie ajustada que preserva la dinamica  sin los extremos.


```{r}
unemp_clean_ts <- ts(df_out$ajustada, start = start_ts, frequency = 12)

```


```{r}
# --- 1) ¿Necesito transformación de varianza? (Box–Cox) ---
lambda <- BoxCox.lambda(unemp_clean_ts)  # λ = −0.9389 (Box–Cox) indica fuerte heterocedasticidad: la varianza crece con el nivel. 
lambda

x_var <- if (abs(lambda - 1) < 0.1) unemp_clean_ts else BoxCox(unemp_clean_ts, lambda)

```


```{r}
# --- 2) ¿Es estacionaria? (ADF/KPSS) y cuántas diferencias pide ---
library(tseries); library(forecast)

adf.test(x_var)         # H0: raíz unitaria (no estacionaria)
kpss.test(x_var)        # H0: estacionaria

d  <- ndiffs(x_var)     # diferencias regulares necesarias
Ds <- nsdiffs(x_var)    # diferencias estacionales (lag 12)
c(d = d, Ds = Ds)

```

no estacionariedad en nivel y la serie necesita diferenciarse dos veces



```{r}
# --- ARIMA con diferencia regular d = 2 (sin diferencia estacional) ---

library(forecast)

# Serie ajustada (ya creada): unemp_clean_ts
# Dummies (ajusta si quieres otras fechas)
ti <- time(unemp_clean_ts)
covid_step  <- as.integer(ti >= 2020 + 2/12)
covid_pulse <- as.integer(ti %in% (2020 + c(3,4,5,6)/12))
X <- cbind(covid_step, covid_pulse)

# Box–Cox (usamos el λ que obtuviste)
lambda <- -0.9389395

# 1) Ajuste ARIMA con d = 2 (sin drift)
fit_d2 <- auto.arima(
  unemp_clean_ts,
  d = 2, D = 0,
  xreg = X,
  lambda = lambda, biasadj = TRUE,
  stepwise = FALSE, approximation = FALSE,
  allowdrift = FALSE, allowmean = FALSE
)

summary(fit_d2)
checkresiduals(fit_d2)   # ACF + Ljung–Box

# 2) Pronóstico 12 meses (escala original)
h  <- 12
Xf <- cbind(covid_step = rep(1, h), covid_pulse = rep(0, h))
fc_d2 <- forecast(fit_d2, h = h, xreg = Xf)

autoplot(fc_d2) +
  labs(title = "Pronóstico desempleo (ARIMA d=2)",
       x = "Año", y = "Tasa (%)")

```




```{r}
# --- 4) Si quedó estacionaria, modelar (ej. ARIMA/ARIMAX) ---
# Dummies opcionales (step/pulsos COVID)
ti <- time(unemp_clean_ts)
covid_step  <- as.integer(ti >= 2020 + 2/12)
covid_pulse <- as.integer(ti %in% (2020 + c(3,4,5,6)/12))
X <- cbind(covid_step, covid_pulse)

fit <- auto.arima(x_var, xreg = X, stepwise = FALSE, approximation = FALSE)
checkresiduals(fit)

```



chatty sugerencia:
```{r}
# --- Serie limpia, dummies e identificación/forecast ---
# Serie ajustada lista para modelar
unemp_clean_ts <- ts(df_out$ajustada, start = start_ts, frequency = 12)

# Dummies de intervención (ajústalas si cambia tu criterio)
ti <- time(unemp_clean_ts)
covid_step  <- as.integer(ti >= 2020 + 2/12)                 # cambio de nivel desde 2020-03
covid_pulse <- as.integer(ti %in% (2020 + c(3,4,5,6)/12))    # pulsos abr–jul 2020
X <- cbind(covid_step, covid_pulse)

# Diferenciación sugerida (referencia)
d  <- ndiffs(unemp_clean_ts); Ds <- nsdiffs(unemp_clean_ts); c(d = d, Ds = Ds)

# Modelo y pronóstico 12 meses
fit <- auto.arima(unemp_clean_ts, xreg = X, stepwise = FALSE, approximation = FALSE)
h   <- 12
Xf  <- cbind(covid_step = rep(1, h), covid_pulse = rep(0, h))
fc  <- forecast(fit, h = h, xreg = Xf)

# Diagnóstico y gráfico
summary(fit)
checkresiduals(fit)
autoplot(fc) + labs(title = "Pronóstico tasa de desempleo (ARIMAX)",
                    x = "Año", y = "Tasa (%)")

```
#⁠Modelos de espacio-estado y filtro de kalma. Agregamos tendencia + componentes no observables




```{r}
# --- Modelo de espacio–estado y filtro de Kalman ---

y <- unemp_clean_ts  # ya  unemp_clean_ts estaba creada

# Modelo estructural seccion 6.6.1 
# y_t = T_t + St + v_t pero en 6.6.2
# ya comienza Formulación como modelo de espacio-estado y escriben ese mismo modelo (ver ecuancion de observacion y  ecuacion de estado) 
#Modelo estructural basico:  y_t = nivel_t + tendencia_t + estacionalidad_t + ruido_t
#En 6.6.2 definimos x_t=(T_t, S_T, S_t-1,S_t-2) y como sabemos por seccion 6.2 el estado de x_t no es observado por lo que casa componente del modelo estructural (tendenciia, estacional y etc)  es no observable y se va estimar con el filtro Kalmam

# Ajustamos un modelo estructural basico, que ya esta escrito en R usanso StrucTS() y BSM tal que BSM= nivel + pendiente + estacionalidad 
fit_BSM <- StructTS(y, type = "BSM")

fit_BSM

#residuos, ACF y Ljung Box
tsdiag(fit_BSM)  
```


```{r}
# Los estados filtrados (estimados en cada t usando info hasta t)
# están en fitted(fit_BSM): nivel, pendiente y componente estacional.
decomp <- cbind(
  desempleo = y,
  fitted(fit_BSM) #objeto que sale de StructTs usado arriba
) ##devuelve una matriz  con los estados filtrados (level, slope(pendiente),seas(estacionalidad)) que son componennres no observables que el filtro de kalman esta estimado en cada timepo 

colnames(decomp) <- c("Desempleo observado", "Nivel", "Pendiente", "Estacionalidad") #junto para visualizar 

par(mfrow = c(4,1), mar = c(3,4,2,1))
plot(decomp[,"Desempleo observado"], main = "Tasa de desempleo (observada)", ylab = "Tasa (%)", xlab = "")
plot(decomp[,"Nivel"], main = "Nivel (tendencia no observable)", ylab = "", xlab = "")
plot(decomp[,"Pendiente"], main = "Pendiente (cambio en la tendencia)", ylab = "", xlab = "")
plot(decomp[,"Estacionalidad"], main = "Componente estacional no observable", ylab = "", xlab = "")
par(mfrow = c(1,1))
#para ver como el modelo estructural esta descomponiendo el desempleo en tendencia+pendiente+ estacionalidad
#FALTA colocar interpretacion
```


```{r}
# Suavizado de Kalman, estados estimados usando toda la serie 6.2 seccion 
suav_BSM <- tsSmooth(fit_BSM)  # hace lo mismo que ksSmooth usada en seccion 6.2.3 pero es la version automatica que r tiene para modelos estructurales 


# Comparamos 
par(mfrow = c(2,1), mar = c(3,4,2,1))
plot(y, main = "Tasa de desempleo vs. nivel suavizado", ylab = "Tasa (%)", xlab = "")
lines(suav_BSM[,"level"], col = 2, lwd = 2)  
legend("topright", legend = c("Observado", "Nivel suavizado"), col = c(1,2), lty = 1, bty = "n")

plot(suav_BSM[,"slope"], main = "Pendiente suavizada (cambio en la tendencia)", ylab = "", xlab = "")
par(mfrow = c(1,1))

```



```{r}
#Pronostico 12 meses con el modelo de espacio estado
h <- 12
fc_BSM <- forecast(fit_BSM, h = h) #h pasos hacia adelante, explicar estas lienas un poco mas 

autoplot(fc_BSM) + # para que quede como el grafico que teniamos de arimax
  labs(title = "Pronóstico tasa de desempleo (BSM)",
       x = "Año", y = "Tasa (%)")


```

```{r}
# Comparar pronosticos ARIMAX y Espacio-estado(BSM)

plot(y,
     xlim = c(start(y)[1],
              end(fc_BSM$mean)[1] + (end(fc_BSM$mean)[2] - 1) / 12),
     main = "Pronóstico de desempleo: ARIMAX vs Modelo BSM",
     ylab = "Tasa de desempleo (%)", xlab = "Año")

lines(fc$mean,      col = 2, lwd = 2)  # ARIMAX
lines(fc_BSM$mean,  col = 4, lwd = 2)  # BSM

legend("topleft",
       legend = c("Observado", "ARIMAX", "Espacio–estado"),
       col = c(1, 2, 4), lty = 1, bty = "n")


```




























